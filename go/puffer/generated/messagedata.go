// Code generated by Diarkis Puffer module: DO NOT EDIT.
//
// Auto-generated by Diarkis Puffer v0.1.0
//
// - Maximum length of a string is 65535 bytes
// - Maximum length of a byte array is 65535 bytes
// - Maximum length of any array is 65535 elements

//lint:file-ignore SA4024 Ignore all code, it's generated.

package generated

import (
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
)

// MessageData represents the command protocol data structure.
type MessageData struct {
	Body      *CastAddBody
	Fid       []byte
	Network   uint8
	Timestamp uint32
	Type      uint8
}

// NewMessageData creates a new instance of MessageData struct.
func NewMessageData() *MessageData {
	return &MessageData{}
}

// Pack encodes MessageData struct to a byte array to be delivered over the command.
func (proto *MessageData) Pack() []byte {
	bytes := make([]byte, 0, proto.PackedSize())
	bodySizeBytes := make([]byte, 2)
	bodyPacked := proto.Body.Pack()
	binary.BigEndian.PutUint16(bodySizeBytes, uint16(len(bodyPacked)))
	bytes = append(bytes, bodySizeBytes...)
	bytes = append(bytes, bodyPacked...)
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Fid)))
	bytes = append(bytes, proto.Fid...)
	bytes = append(bytes, proto.Network)
	bytes = binary.BigEndian.AppendUint32(bytes, uint32(proto.Timestamp))
	bytes = append(bytes, proto.Type)
	return bytes
}

// Unpack decodes the command payload byte array to MessageData struct.
func (proto *MessageData) Unpack(bytes []byte) error {
	unpackErr := errors.New("MessageDataUnpackError")
	if len(bytes) < 10 {
		return unpackErr
	}
	offset := 0
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Body: %w", unpackErr)
	}
	bodySizeBytes := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	offset += 2
	if bodySizeBytes+offset > len(bytes) {
		return fmt.Errorf("payload too short to unpack Body: %w", unpackErr)
	}
	bodyBytes := bytes[offset : offset+bodySizeBytes : offset+bodySizeBytes]
	proto.Body = &CastAddBody{}
	if err := proto.Body.Unpack(bodyBytes); err != nil {
		return fmt.Errorf("failed to unpack Body: %w", err)
	}
	offset += bodySizeBytes
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Fid: %w", unpackErr)
	}
	fidSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if fidSize+offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Fid: %w", unpackErr)
	}
	offset += 2
	proto.Fid = make([]byte, fidSize)
	copy(proto.Fid, bytes[offset:offset+fidSize:offset+fidSize])
	offset += fidSize
	if offset+1 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Network: %w", unpackErr)
	}
	proto.Network = uint8(bytes[offset])
	offset++
	if offset+4 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Timestamp: %w", unpackErr)
	}
	proto.Timestamp = binary.BigEndian.Uint32(bytes[offset : offset+4])
	offset += 4
	if offset+1 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Type: %w", unpackErr)
	}
	proto.Type = uint8(bytes[offset])
	offset++
	return nil
}

// PackedSize returns the estimated packed size of the struct.
func (proto *MessageData) PackedSize() int {
	var packedSize = 0
	packedSize += proto.Body.PackedSize()
	packedSize += 2 + len(proto.Fid)
	packedSize += 1
	packedSize += 4
	packedSize += 1
	return packedSize
}

func (proto *MessageData) String() string {
	var list []string
	list = append(list, fmt.Sprint("Body = ", proto.Body.String()))
	list = append(list, fmt.Sprint("Fid = ", proto.Fid))
	list = append(list, fmt.Sprint("Network = ", proto.Network))
	list = append(list, fmt.Sprint("Timestamp = ", proto.Timestamp))
	list = append(list, fmt.Sprint("Type = ", proto.Type))
	return strings.Join(list, " | ")
}

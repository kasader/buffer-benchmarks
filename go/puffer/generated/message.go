// Code generated by Diarkis Puffer module: DO NOT EDIT.
//
// Auto-generated by Diarkis Puffer v0.1.0
//
// - Maximum length of a string is 65535 bytes
// - Maximum length of a byte array is 65535 bytes
// - Maximum length of any array is 65535 elements

//lint:file-ignore SA4024 Ignore all code, it's generated.

package generated

import (
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
)

// Message represents the command protocol data structure.
type Message struct {
	Data             []byte
	Hash             []byte
	Hash_scheme      uint8
	Signature        []byte
	Signature_scheme uint8
	Signer           []byte
}

// NewMessage creates a new instance of Message struct.
func NewMessage() *Message {
	return &Message{}
}

// Pack encodes Message struct to a byte array to be delivered over the command.
func (proto *Message) Pack() []byte {
	bytes := make([]byte, 0, proto.PackedSize())
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Data)))
	bytes = append(bytes, proto.Data...)
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Hash)))
	bytes = append(bytes, proto.Hash...)
	bytes = append(bytes, proto.Hash_scheme)
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Signature)))
	bytes = append(bytes, proto.Signature...)
	bytes = append(bytes, proto.Signature_scheme)
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Signer)))
	bytes = append(bytes, proto.Signer...)
	return bytes
}

// Unpack decodes the command payload byte array to Message struct.
func (proto *Message) Unpack(bytes []byte) error {
	unpackErr := errors.New("MessageUnpackError")
	if len(bytes) < 10 {
		return unpackErr
	}
	offset := 0
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Data: %w", unpackErr)
	}
	dataSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if dataSize+offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Data: %w", unpackErr)
	}
	offset += 2
	proto.Data = make([]byte, dataSize)
	copy(proto.Data, bytes[offset:offset+dataSize:offset+dataSize])
	offset += dataSize
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Hash: %w", unpackErr)
	}
	hashSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if hashSize+offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Hash: %w", unpackErr)
	}
	offset += 2
	proto.Hash = make([]byte, hashSize)
	copy(proto.Hash, bytes[offset:offset+hashSize:offset+hashSize])
	offset += hashSize
	if offset+1 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Hash_scheme: %w", unpackErr)
	}
	proto.Hash_scheme = uint8(bytes[offset])
	offset++
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Signature: %w", unpackErr)
	}
	signatureSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if signatureSize+offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Signature: %w", unpackErr)
	}
	offset += 2
	proto.Signature = make([]byte, signatureSize)
	copy(proto.Signature, bytes[offset:offset+signatureSize:offset+signatureSize])
	offset += signatureSize
	if offset+1 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Signature_scheme: %w", unpackErr)
	}
	proto.Signature_scheme = uint8(bytes[offset])
	offset++
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Signer: %w", unpackErr)
	}
	signerSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if signerSize+offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Signer: %w", unpackErr)
	}
	offset += 2
	proto.Signer = make([]byte, signerSize)
	copy(proto.Signer, bytes[offset:offset+signerSize:offset+signerSize])
	offset += signerSize
	return nil
}

// PackedSize returns the estimated packed size of the struct.
func (proto *Message) PackedSize() int {
	var packedSize = 0
	packedSize += 2 + len(proto.Data)
	packedSize += 2 + len(proto.Hash)
	packedSize += 1
	packedSize += 2 + len(proto.Signature)
	packedSize += 1
	packedSize += 2 + len(proto.Signer)
	return packedSize
}

func (proto *Message) String() string {
	var list []string
	list = append(list, fmt.Sprint("Data = ", proto.Data))
	list = append(list, fmt.Sprint("Hash = ", proto.Hash))
	list = append(list, fmt.Sprint("Hash_scheme = ", proto.Hash_scheme))
	list = append(list, fmt.Sprint("Signature = ", proto.Signature))
	list = append(list, fmt.Sprint("Signature_scheme = ", proto.Signature_scheme))
	list = append(list, fmt.Sprint("Signer = ", proto.Signer))
	return strings.Join(list, " | ")
}

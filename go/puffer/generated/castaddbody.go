// Code generated by Diarkis Puffer module: DO NOT EDIT.
//
// Auto-generated by Diarkis Puffer v0.1.0
//
// - Maximum length of a string is 65535 bytes
// - Maximum length of a byte array is 65535 bytes
// - Maximum length of any array is 65535 elements

//lint:file-ignore SA4024 Ignore all code, it's generated.

package generated

import (
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
)

// CastAddBody represents the command protocol data structure.
type CastAddBody struct {
	Embeds   []string
	Mentions *UserId
	Parent   *CastId
	Text     string
}

// NewCastAddBody creates a new instance of CastAddBody struct.
func NewCastAddBody() *CastAddBody {
	return &CastAddBody{}
}

// Pack encodes CastAddBody struct to a byte array to be delivered over the command.
func (proto *CastAddBody) Pack() []byte {
	bytes := make([]byte, 0, proto.PackedSize())
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Embeds)))
	for i := 0; i < len(proto.Embeds); i++ {
		bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Embeds[i])))
		bytes = append(bytes, []byte(proto.Embeds[i])...)
	}
	mentionsSizeBytes := make([]byte, 2)
	mentionsPacked := proto.Mentions.Pack()
	binary.BigEndian.PutUint16(mentionsSizeBytes, uint16(len(mentionsPacked)))
	bytes = append(bytes, mentionsSizeBytes...)
	bytes = append(bytes, mentionsPacked...)
	parentSizeBytes := make([]byte, 2)
	parentPacked := proto.Parent.Pack()
	binary.BigEndian.PutUint16(parentSizeBytes, uint16(len(parentPacked)))
	bytes = append(bytes, parentSizeBytes...)
	bytes = append(bytes, parentPacked...)
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(len(proto.Text)))
	bytes = append(bytes, []byte(proto.Text)...)
	return bytes
}

// Unpack decodes the command payload byte array to CastAddBody struct.
func (proto *CastAddBody) Unpack(bytes []byte) error {
	unpackErr := errors.New("CastAddBodyUnpackError")
	if len(bytes) < 8 {
		return unpackErr
	}
	offset := 0
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Embeds: %w", unpackErr)
	}
	embedsCount := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if embedsCount*2+offset+2 > len(bytes) {
		return errors.New("UnpackError")
	}
	offset += 2
	proto.Embeds = make([]string, 0, embedsCount)
	for i := 0; i < embedsCount; i++ {
		if offset+2 > len(bytes) {
			return fmt.Errorf("payload too short to unpack Embeds at index %d: %w", i, unpackErr)
		}
		size := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
		offset += 2
		if offset+size > len(bytes) {
			return fmt.Errorf("payload too short to unpack Embeds at index %d: %w", i, unpackErr)
		}
		proto.Embeds = append(proto.Embeds, string(bytes[offset:offset+size:offset+size]))
		offset += size
	}
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Mentions: %w", unpackErr)
	}
	mentionsSizeBytes := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	offset += 2
	if mentionsSizeBytes+offset > len(bytes) {
		return fmt.Errorf("payload too short to unpack Mentions: %w", unpackErr)
	}
	mentionsBytes := bytes[offset : offset+mentionsSizeBytes : offset+mentionsSizeBytes]
	proto.Mentions = &UserId{}
	if err := proto.Mentions.Unpack(mentionsBytes); err != nil {
		return fmt.Errorf("failed to unpack Mentions: %w", err)
	}
	offset += mentionsSizeBytes
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Parent: %w", unpackErr)
	}
	parentSizeBytes := int(binary.BigEndian.Uint16((bytes[offset : offset+2])))
	offset += 2
	if parentSizeBytes+offset > len(bytes) {
		return fmt.Errorf("payload too short to unpack Parent: %w", unpackErr)
	}
	parentBytes := bytes[offset : offset+parentSizeBytes : offset+parentSizeBytes]
	proto.Parent = &CastId{}
	if err := proto.Parent.Unpack(parentBytes); err != nil {
		return fmt.Errorf("failed to unpack Parent: %w", err)
	}
	offset += parentSizeBytes
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Text: %w", unpackErr)
	}
	textSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if textSize+offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Text: %w", unpackErr)
	}
	offset += 2
	proto.Text = string(bytes[offset : offset+textSize : offset+textSize])
	offset += textSize
	return nil
}

// PackedSize returns the estimated packed size of the struct.
func (proto *CastAddBody) PackedSize() int {
	var packedSize = 0
	packedSize += 2
	for _, v := range proto.Embeds {
		packedSize += 2 + len(v)
	}
	packedSize += proto.Mentions.PackedSize()
	packedSize += proto.Parent.PackedSize()
	packedSize += 2 + len(proto.Text)
	return packedSize
}

func (proto *CastAddBody) String() string {
	var list []string
	list = append(list, fmt.Sprint("Embeds = ", proto.Embeds))
	list = append(list, fmt.Sprint("Mentions = ", proto.Mentions.String()))
	list = append(list, fmt.Sprint("Parent = ", proto.Parent.String()))
	list = append(list, fmt.Sprint("Text = ", proto.Text))
	return strings.Join(list, " | ")
}

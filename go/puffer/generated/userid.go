// Code generated by Diarkis Puffer module: DO NOT EDIT.
//
// Auto-generated by Diarkis Puffer v0.1.0
//
// - Maximum length of a string is 65535 bytes
// - Maximum length of a byte array is 65535 bytes
// - Maximum length of any array is 65535 elements

//lint:file-ignore SA4024 Ignore all code, it's generated.

package generated

import (
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
)

// UserId represents the command protocol data structure.
type UserId struct {
	Fid []byte
}

// NewUserId creates a new instance of UserId struct.
func NewUserId() *UserId {
	return &UserId{}
}

// Pack encodes UserId struct to a byte array to be delivered over the command.
func (proto *UserId) Pack() []byte {
	bytes := make([]byte, 0, proto.PackedSize())
	fidLen := 0
	if proto != nil {
		fidLen = len(proto.Fid)
	}
	bytes = binary.BigEndian.AppendUint16(bytes, uint16(fidLen))
	if proto != nil {
		bytes = append(bytes, proto.Fid...)
	} else {
		bytes = append(bytes, nil...)
	}
	return bytes
}

// Unpack decodes the command payload byte array to UserId struct.
func (proto *UserId) Unpack(bytes []byte) error {
	unpackErr := errors.New("UserIdUnpackError")
	if len(bytes) < 2 {
		return unpackErr
	}
	offset := 0
	if offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Fid: %w", unpackErr)
	}
	fidSize := int(binary.BigEndian.Uint16(bytes[offset : offset+2]))
	if fidSize+offset+2 > len(bytes) {
		return fmt.Errorf("payload too short to unpack Fid: %w", unpackErr)
	}
	offset += 2
	proto.Fid = make([]byte, fidSize)
	copy(proto.Fid, bytes[offset:offset+fidSize:offset+fidSize])
	offset += fidSize
	return nil
}

// PackedSize returns the estimated packed size of the struct.
func (proto *UserId) PackedSize() int {
	if proto == nil {
		return 0
	}
	var packedSize = 0
	packedSize += 2 + len(proto.Fid)
	return packedSize
}

func (proto *UserId) String() string {
	var list []string
	list = append(list, fmt.Sprint("Fid = ", proto.Fid))
	return strings.Join(list, " | ")
}
